{"mappings":"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","sources":["<anon>","src/scripts/main.js","src/modules/Tile.class.js","src/modules/Game.class.js"],"sourcesContent":["\"use strict\";\nvar $a3a4bece0086b835$exports = {};\nclass $a3a4bece0086b835$var$Tile {\n    constructor(value, field){\n        this.value = value;\n        this.tileElement = document.createElement(\"div\");\n        this.tileElement.classList.add(\"tile\");\n        field.append(this.tileElement);\n        this.setValue(value);\n    }\n    setCoords(row, col) {\n        this.row = row;\n        this.col = col;\n        this.tileElement.style.setProperty(\"--row\", row);\n        this.tileElement.style.setProperty(\"--col\", col);\n    }\n    setValue(value) {\n        this.value = value;\n        this.tileElement.classList.add(`tile--${this.value}`);\n        this.tileElement.textContent = this.value;\n    }\n    removeFromDom() {\n        this.tileElement.remove();\n    }\n    waitForTransitionEnd() {\n        return new Promise((resolve)=>{\n            this.tileElement.addEventListener(\"transitionend\", resolve, {\n                once: true\n            });\n        });\n    }\n}\n$a3a4bece0086b835$exports = $a3a4bece0086b835$var$Tile;\n\n\nvar $a5fd07fa01589658$exports = {};\nclass $a5fd07fa01589658$var$Game {\n    constructor(initialState = [\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ]\n    ]){\n        this.initialState = initialState;\n        this.currentState = JSON.parse(JSON.stringify(this.initialState));\n        this.status = \"idle\";\n        this.score = 0;\n        this.left = \"ArrowLeft\";\n        this.right = \"ArrowRight\";\n        this.up = \"ArrowUp\";\n        this.down = \"ArrowDown\";\n    }\n    moveLeft() {\n        if (this.status === \"playing\") this.slideTiles(this.left, this.currentState);\n    }\n    moveRight() {\n        if (this.status === \"playing\") this.slideTiles(this.right, this.currentState);\n    }\n    moveUp() {\n        if (this.status === \"playing\") this.slideTiles(this.up, this.currentState);\n    }\n    moveDown() {\n        if (this.status === \"playing\") this.slideTiles(this.down, this.currentState);\n    }\n    getScore() {\n        return this.score;\n    }\n    getState() {\n        return this.currentState;\n    }\n    getStatus() {\n        return this.status;\n    }\n    start() {\n        this.status = \"playing\";\n        this.getRandomMatrixValue();\n        this.getRandomMatrixValue();\n    }\n    restart() {\n        this.score = 0;\n        this.status = \"idle\";\n        this.currentState = JSON.parse(JSON.stringify(this.initialState));\n    }\n    getRandomValue() {\n        return Math.random() > 0.9 ? 4 : 2;\n    }\n    getRandomCell() {\n        const emptyCells = [];\n        for(let i = 0; i < this.currentState.length; i++){\n            for(let j = 0; j < this.currentState[i].length; j++)if (this.currentState[i][j] === 0) emptyCells.push({\n                row: i,\n                col: j\n            });\n        }\n        if (emptyCells.length === 0) return null;\n        const randomIndex = Math.floor(Math.random() * emptyCells.length);\n        return emptyCells[randomIndex];\n    }\n    getRandomMatrixValue() {\n        const { row: row, col: col } = this.getRandomCell();\n        const value = this.getRandomValue();\n        if (row >= 0 && col >= 0 && value !== 0) this.currentState[row][col] = value;\n    }\n    groupCellsByColumn(matrix) {\n        const newGroup = [];\n        if (matrix.length > 0) for(let j = 0; j < matrix.length; j++)newGroup.push(matrix.map((row)=>row[j]));\n        return newGroup;\n    }\n    slideTiles(direction, groupedMatrix) {\n        let hasChanged = false;\n        if (direction === this.left || direction === this.right) for(let i = 0; i < groupedMatrix.length; i++){\n            const row = this.currentState[i];\n            const newGroup = this.slideTilesInGroup(row, direction === this.right);\n            if (row.join(\",\") !== newGroup.join(\",\")) {\n                hasChanged = true;\n                this.currentState[i] = newGroup;\n            }\n        }\n        else if (direction === this.up || direction === this.down) for(let j = 0; j < groupedMatrix.length; j++){\n            const column = this.currentState.map((line)=>line[j]);\n            const newColumn = this.slideTilesInGroup(column, direction === this.down);\n            for(let i = 0; i < groupedMatrix.length; i++)if (this.currentState[i][j] !== newColumn[i]) {\n                hasChanged = true;\n                this.currentState[i][j] = newColumn[i];\n            }\n        }\n        if (hasChanged) {\n            this.getRandomMatrixValue();\n            this.checkGameOver();\n        }\n    }\n    slideTilesInGroup(group, isReverse) {\n        const newGroup = group.filter((cell)=>cell !== 0);\n        if (isReverse) newGroup.reverse();\n        for(let i = 0; i < newGroup.length; i++)if (newGroup[i] === newGroup[i + 1]) {\n            newGroup[i] *= 2;\n            this.score += newGroup[i];\n            newGroup.splice(i + 1, 1);\n            if (newGroup[i] === 2048) this.status = \"win\";\n        }\n        while(newGroup.length < group.length)newGroup.push(0);\n        if (isReverse) newGroup.reverse();\n        return newGroup;\n    }\n    checkGameOver() {\n        for(let i = 0; i < this.currentState.length; i++)for(let j = 0; j < this.currentState[i].length; j++){\n            if (this.currentState[i][j] === 0) return;\n            if (j < this.currentState[i].length - 1 && this.currentState[i][j] === this.currentState[i][j + 1]) return;\n            if (i < this.currentState[i].length - 1 && this.currentState[i][j] === this.currentState[i + 1][j]) return;\n        }\n        this.status = \"lose\";\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    const gameButton = document.querySelector(\".button\");\n    const messageWin = document.querySelector(\".message-win\");\n    const messageLose = document.querySelector(\".message-lose\");\n    const messageStart = document.querySelector(\".message-start\");\n    const scoreElement = document.querySelector(\".game-score\");\n    const gameField = document.querySelector(\".game-field\");\n    const themeSwitcher = document.querySelector(\".theme-switcher\");\n    const fieldSize = 4;\n    const cellsCount = fieldSize * fieldSize;\n    const cells = [];\n    initCells();\n    const game = new $a5fd07fa01589658$exports();\n    const cellsGroupedByColumn = groupCellsByColumn();\n    const cellsGroupedByReversedColumn = groupCellsByColumn().map((column)=>{\n        return column.reverse();\n    });\n    const cellsGroupedByRow = groupCellsByRow();\n    const cellsGroupedByReversedRow = groupCellsByRow().map((row)=>{\n        return row.reverse();\n    });\n    function renderBoard() {\n        const gameMatrix = game.getState();\n        for(let i = 0; i < gameMatrix.length; i++)for(let j = 0; j < gameMatrix[i].length; j++){\n            const value = gameMatrix[i][j];\n            if (value !== 0) {\n                const existingCell = cells.find((cell)=>cell.row === i && cell.col === j);\n                if (existingCell.linkedTile) continue;\n                const newTile = new $a3a4bece0086b835$exports(value, gameField);\n                linkTile(newTile, existingCell);\n            }\n        }\n    }\n    function initCells() {\n        for(let i = 0; i < cellsCount; i++)cells.push({\n            row: Math.floor(i / fieldSize),\n            col: i % fieldSize\n        });\n    }\n    function clearBoard() {\n        for (const cell of cells)if (cell.linkedTile) {\n            cell.linkedTile.removeFromDom();\n            cell.linkedTile = null;\n            cell.linkedTileForMerge = null;\n        }\n    }\n    function linkTile(tile, cell) {\n        tile.setCoords(cell.row, cell.col);\n        cell.linkedTile = tile;\n    }\n    function unlinkTile(cell) {\n        cell.linkedTile = null;\n    }\n    function linkTileForMerge(tile, cell) {\n        tile.setCoords(cell.row, cell.col);\n        cell.linkedTileForMerge = tile;\n    }\n    function unlinkTileForMerge(cell) {\n        cell.linkedTileForMerge = null;\n    }\n    function canAccept(targetCell, currentTile) {\n        return !targetCell.linkedTile || !targetCell.linkedTileForMerge && targetCell.linkedTile.value === currentTile.value;\n    }\n    function groupCellsByColumn() {\n        return cells.reduce((groupedCells, cell)=>{\n            groupedCells[cell.col] = groupedCells[cell.col] || [];\n            groupedCells[cell.col][cell.row] = cell;\n            return groupedCells;\n        }, []);\n    }\n    function groupCellsByRow() {\n        return cells.reduce((groupedCells, cell)=>{\n            groupedCells[cell.col] = groupedCells[cell.col] || [];\n            groupedCells[cell.row][cell.col] = cell;\n            return groupedCells;\n        }, []);\n    }\n    async function slideTiles(groupedCells) {\n        const promises = [];\n        groupedCells.forEach((group)=>slideTilesInGroup(group, promises));\n        await Promise.all(promises);\n        cells.forEach((cell)=>cell.linkedTileForMerge && mergeTiles(cell));\n    }\n    function slideTilesInGroup(group, promises) {\n        for(let i = 1; i < group.length; i++){\n            if (!group[i].linkedTile) continue;\n            const cellWithTile = group[i];\n            let targetCell = {};\n            let j = i - 1;\n            while(j >= 0 && canAccept(group[j], cellWithTile.linkedTile)){\n                targetCell = group[j];\n                j--;\n            }\n            if (Object.keys(targetCell).length === 0) continue;\n            promises.push(cellWithTile.linkedTile.waitForTransitionEnd());\n            if (!targetCell.linkedTile) linkTile(cellWithTile.linkedTile, targetCell);\n            else linkTileForMerge(cellWithTile.linkedTile, targetCell);\n            unlinkTile(cellWithTile);\n        }\n    }\n    function mergeTiles(cell) {\n        cell.linkedTile.setValue(cell.linkedTile.value + cell.linkedTileForMerge.value);\n        cell.linkedTileForMerge.removeFromDom();\n        unlinkTileForMerge(cell);\n    }\n    gameButton.addEventListener(\"click\", function(e) {\n        if (e.target.matches(\".start\") && game.getStatus() === \"idle\") {\n            game.start();\n            renderBoard();\n            messageStart.classList.add(\"hidden\");\n        } else if (e.target.matches(\".restart\")) {\n            game.restart();\n            clearBoard();\n            scoreElement.textContent = game.getScore();\n            e.target.classList.remove(\"restart\");\n            e.target.classList.add(\"start\");\n            e.target.textContent = \"Start\";\n            messageWin.classList.add(\"hidden\");\n            messageLose.classList.add(\"hidden\");\n            messageStart.classList.remove(\"hidden\");\n        }\n        setupInputOnce();\n    });\n    themeSwitcher.addEventListener(\"click\", function() {\n        const body = document.querySelector(\".body\");\n        const themeLight = document.querySelector(\".theme-switcher__light\");\n        const themeDark = document.querySelector(\".theme-switcher__dark\");\n        const fieldCells = gameField.querySelectorAll(\".field-cell\");\n        if (body.matches(\".body--light-theme\")) {\n            body.classList.remove(\"body--light-theme\");\n            body.classList.add(\"body--dark-theme\");\n            themeLight.classList.remove(\"active\");\n            themeDark.classList.add(\"active\");\n            gameField.classList.add(\"dark-theme\");\n            [\n                ...fieldCells\n            ].forEach((cell)=>cell.classList.add(\"dark-theme\"));\n        } else {\n            body.classList.add(\"body--light-theme\");\n            body.classList.remove(\"body--dark-theme\");\n            themeLight.classList.add(\"active\");\n            themeDark.classList.remove(\"active\");\n            gameField.classList.remove(\"dark-theme\");\n            [\n                ...fieldCells\n            ].forEach((cell)=>cell.classList.remove(\"dark-theme\"));\n        }\n    });\n    const buttonUp = document.querySelector(\".control__button--up\");\n    const buttonDown = document.querySelector(\".control__button--down\");\n    const buttonLeft = document.querySelector(\".control__button--left\");\n    const buttonRight = document.querySelector(\".control__button--right\");\n    buttonUp.addEventListener(\"click\", ()=>{\n        const ev = new KeyboardEvent(\"keydown\", {\n            key: \"ArrowUp\"\n        });\n        handleInput(ev);\n        setupInputOnce();\n    });\n    buttonDown.addEventListener(\"click\", ()=>{\n        const ev = new KeyboardEvent(\"keydown\", {\n            key: \"ArrowDown\"\n        });\n        handleInput(ev);\n        setupInputOnce();\n    });\n    buttonLeft.addEventListener(\"click\", ()=>{\n        const ev = new KeyboardEvent(\"keydown\", {\n            key: \"ArrowLeft\"\n        });\n        handleInput(ev);\n        setupInputOnce();\n    });\n    buttonRight.addEventListener(\"click\", ()=>{\n        const ev = new KeyboardEvent(\"keydown\", {\n            key: \"ArrowRight\"\n        });\n        handleInput(ev);\n        setupInputOnce();\n    });\n    function setupInputOnce() {\n        window.addEventListener(\"keydown\", handleInput, {\n            once: true\n        });\n    }\n    async function handleInput(ev) {\n        ev.preventDefault();\n        if (game.getStatus() === \"playing\") {\n            switch(ev.key){\n                case \"ArrowUp\":\n                    game.moveUp();\n                    await slideTiles(cellsGroupedByColumn);\n                    setupInputOnce();\n                    break;\n                case \"ArrowDown\":\n                    game.moveDown();\n                    await slideTiles(cellsGroupedByReversedColumn);\n                    setupInputOnce();\n                    break;\n                case \"ArrowLeft\":\n                    game.moveLeft();\n                    await slideTiles(cellsGroupedByRow);\n                    setupInputOnce();\n                    break;\n                case \"ArrowRight\":\n                    game.moveRight();\n                    await slideTiles(cellsGroupedByReversedRow);\n                    setupInputOnce();\n                    break;\n                default:\n                    return setupInputOnce();\n            }\n            gameButton.classList.remove(\"start\");\n            gameButton.classList.add(\"restart\");\n            gameButton.textContent = \"Restart\";\n        }\n        renderBoard();\n        if (scoreElement) scoreElement.textContent = game.getScore();\n        if (game.getStatus() === \"lose\") messageLose.classList.remove(\"hidden\");\n        if (game.getStatus() === \"win\") messageWin.classList.remove(\"hidden\");\n        setupInputOnce();\n    }\n});\n\n\n//# sourceMappingURL=index.574760c1.js.map\n","'use strict';\n\nconst Tile = require('../modules/Tile.class');\nconst Game = require('../modules/Game.class');\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const gameButton = document.querySelector('.button');\n  const messageWin = document.querySelector('.message-win');\n  const messageLose = document.querySelector('.message-lose');\n  const messageStart = document.querySelector('.message-start');\n  const scoreElement = document.querySelector('.game-score');\n  const gameField = document.querySelector('.game-field');\n  const themeSwitcher = document.querySelector('.theme-switcher');\n\n  const fieldSize = 4;\n  const cellsCount = fieldSize * fieldSize;\n  const cells = [];\n\n  initCells();\n\n  const game = new Game();\n  const cellsGroupedByColumn = groupCellsByColumn();\n  const cellsGroupedByReversedColumn = groupCellsByColumn().map((column) => {\n    return column.reverse();\n  });\n  const cellsGroupedByRow = groupCellsByRow();\n  const cellsGroupedByReversedRow = groupCellsByRow().map((row) => {\n    return row.reverse();\n  });\n\n  function renderBoard() {\n    const gameMatrix = game.getState();\n\n    for (let i = 0; i < gameMatrix.length; i++) {\n      for (let j = 0; j < gameMatrix[i].length; j++) {\n        const value = gameMatrix[i][j];\n\n        if (value !== 0) {\n          const existingCell = cells.find(\n            (cell) => cell.row === i && cell.col === j,\n          );\n\n          if (existingCell.linkedTile) {\n            continue;\n          }\n\n          const newTile = new Tile(value, gameField);\n\n          linkTile(newTile, existingCell);\n        }\n      }\n    }\n  }\n\n  function initCells() {\n    for (let i = 0; i < cellsCount; i++) {\n      cells.push({ row: Math.floor(i / fieldSize), col: i % fieldSize });\n    }\n  }\n\n  function clearBoard() {\n    for (const cell of cells) {\n      if (cell.linkedTile) {\n        cell.linkedTile.removeFromDom();\n        cell.linkedTile = null;\n        cell.linkedTileForMerge = null;\n      }\n    }\n  }\n\n  function linkTile(tile, cell) {\n    tile.setCoords(cell.row, cell.col);\n    cell.linkedTile = tile;\n  }\n\n  function unlinkTile(cell) {\n    cell.linkedTile = null;\n  }\n\n  function linkTileForMerge(tile, cell) {\n    tile.setCoords(cell.row, cell.col);\n    cell.linkedTileForMerge = tile;\n  }\n\n  function unlinkTileForMerge(cell) {\n    cell.linkedTileForMerge = null;\n  }\n\n  function canAccept(targetCell, currentTile) {\n    return (\n      !targetCell.linkedTile ||\n      (!targetCell.linkedTileForMerge &&\n        targetCell.linkedTile.value === currentTile.value)\n    );\n  }\n\n  function groupCellsByColumn() {\n    return cells.reduce((groupedCells, cell) => {\n      groupedCells[cell.col] = groupedCells[cell.col] || [];\n      groupedCells[cell.col][cell.row] = cell;\n\n      return groupedCells;\n    }, []);\n  }\n\n  function groupCellsByRow() {\n    return cells.reduce((groupedCells, cell) => {\n      groupedCells[cell.col] = groupedCells[cell.col] || [];\n      groupedCells[cell.row][cell.col] = cell;\n\n      return groupedCells;\n    }, []);\n  }\n\n  async function slideTiles(groupedCells) {\n    const promises = [];\n\n    groupedCells.forEach((group) => slideTilesInGroup(group, promises));\n\n    await Promise.all(promises);\n\n    cells.forEach((cell) => cell.linkedTileForMerge && mergeTiles(cell));\n  }\n\n  function slideTilesInGroup(group, promises) {\n    for (let i = 1; i < group.length; i++) {\n      if (!group[i].linkedTile) {\n        continue;\n      }\n\n      const cellWithTile = group[i];\n      let targetCell = {};\n      let j = i - 1;\n\n      while (j >= 0 && canAccept(group[j], cellWithTile.linkedTile)) {\n        targetCell = group[j];\n        j--;\n      }\n\n      if (Object.keys(targetCell).length === 0) {\n        continue;\n      }\n\n      promises.push(cellWithTile.linkedTile.waitForTransitionEnd());\n\n      if (!targetCell.linkedTile) {\n        linkTile(cellWithTile.linkedTile, targetCell);\n      } else {\n        linkTileForMerge(cellWithTile.linkedTile, targetCell);\n      }\n\n      unlinkTile(cellWithTile);\n    }\n  }\n\n  function mergeTiles(cell) {\n    cell.linkedTile.setValue(\n      cell.linkedTile.value + cell.linkedTileForMerge.value,\n    );\n    cell.linkedTileForMerge.removeFromDom();\n    unlinkTileForMerge(cell);\n  }\n\n  gameButton.addEventListener('click', function (e) {\n    if (e.target.matches('.start') && game.getStatus() === 'idle') {\n      game.start();\n      renderBoard();\n\n      messageStart.classList.add('hidden');\n    } else if (e.target.matches('.restart')) {\n      game.restart();\n      clearBoard();\n\n      scoreElement.textContent = game.getScore();\n      e.target.classList.remove('restart');\n      e.target.classList.add('start');\n      e.target.textContent = 'Start';\n      messageWin.classList.add('hidden');\n      messageLose.classList.add('hidden');\n      messageStart.classList.remove('hidden');\n    }\n    setupInputOnce();\n  });\n\n  themeSwitcher.addEventListener('click', function () {\n    const body = document.querySelector('.body');\n    const themeLight = document.querySelector('.theme-switcher__light');\n    const themeDark = document.querySelector('.theme-switcher__dark');\n    const fieldCells = gameField.querySelectorAll('.field-cell');\n\n    if (body.matches('.body--light-theme')) {\n      body.classList.remove('body--light-theme');\n      body.classList.add('body--dark-theme');\n      themeLight.classList.remove('active');\n      themeDark.classList.add('active');\n      gameField.classList.add('dark-theme');\n      [...fieldCells].forEach((cell) => cell.classList.add('dark-theme'));\n    } else {\n      body.classList.add('body--light-theme');\n      body.classList.remove('body--dark-theme');\n      themeLight.classList.add('active');\n      themeDark.classList.remove('active');\n      gameField.classList.remove('dark-theme');\n      [...fieldCells].forEach((cell) => cell.classList.remove('dark-theme'));\n    }\n  });\n\n  const buttonUp = document.querySelector('.control__button--up');\n  const buttonDown = document.querySelector('.control__button--down');\n  const buttonLeft = document.querySelector('.control__button--left');\n  const buttonRight = document.querySelector('.control__button--right');\n\n  buttonUp.addEventListener('click', () => {\n    const ev = new KeyboardEvent('keydown', { key: 'ArrowUp' });\n\n    handleInput(ev);\n    setupInputOnce();\n  });\n\n  buttonDown.addEventListener('click', () => {\n    const ev = new KeyboardEvent('keydown', { key: 'ArrowDown' });\n\n    handleInput(ev);\n    setupInputOnce();\n  });\n\n  buttonLeft.addEventListener('click', () => {\n    const ev = new KeyboardEvent('keydown', { key: 'ArrowLeft' });\n\n    handleInput(ev);\n    setupInputOnce();\n  });\n\n  buttonRight.addEventListener('click', () => {\n    const ev = new KeyboardEvent('keydown', { key: 'ArrowRight' });\n\n    handleInput(ev);\n    setupInputOnce();\n  });\n\n  function setupInputOnce() {\n    window.addEventListener('keydown', handleInput, { once: true });\n  }\n\n  async function handleInput(ev) {\n    ev.preventDefault();\n\n    if (game.getStatus() === 'playing') {\n      switch (ev.key) {\n        case 'ArrowUp':\n          game.moveUp();\n          await slideTiles(cellsGroupedByColumn);\n          setupInputOnce();\n          break;\n        case 'ArrowDown':\n          game.moveDown();\n          await slideTiles(cellsGroupedByReversedColumn);\n          setupInputOnce();\n          break;\n        case 'ArrowLeft':\n          game.moveLeft();\n          await slideTiles(cellsGroupedByRow);\n          setupInputOnce();\n          break;\n        case 'ArrowRight':\n          game.moveRight();\n          await slideTiles(cellsGroupedByReversedRow);\n          setupInputOnce();\n          break;\n\n        default:\n          return setupInputOnce();\n      }\n\n      gameButton.classList.remove('start');\n      gameButton.classList.add('restart');\n      gameButton.textContent = 'Restart';\n    }\n    renderBoard();\n\n    if (scoreElement) {\n      scoreElement.textContent = game.getScore();\n    }\n\n    if (game.getStatus() === 'lose') {\n      messageLose.classList.remove('hidden');\n    }\n\n    if (game.getStatus() === 'win') {\n      messageWin.classList.remove('hidden');\n    }\n\n    setupInputOnce();\n  }\n});\n","class Tile {\n  constructor(value, field) {\n    this.value = value;\n    this.tileElement = document.createElement('div');\n    this.tileElement.classList.add('tile');\n    field.append(this.tileElement);\n    this.setValue(value);\n  }\n\n  setCoords(row, col) {\n    this.row = row;\n    this.col = col;\n\n    this.tileElement.style.setProperty('--row', row);\n    this.tileElement.style.setProperty('--col', col);\n  }\n\n  setValue(value) {\n    this.value = value;\n    this.tileElement.classList.add(`tile--${this.value}`);\n    this.tileElement.textContent = this.value;\n  }\n\n  removeFromDom() {\n    this.tileElement.remove();\n  }\n\n  waitForTransitionEnd() {\n    return new Promise((resolve) => {\n      this.tileElement.addEventListener('transitionend', resolve, {\n        once: true,\n      });\n    });\n  }\n}\n\nmodule.exports = Tile;\n","class Game {\n  constructor(\n    initialState = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ],\n  ) {\n    this.initialState = initialState;\n    this.currentState = JSON.parse(JSON.stringify(this.initialState));\n    this.status = 'idle';\n    this.score = 0;\n\n    this.left = 'ArrowLeft';\n    this.right = 'ArrowRight';\n    this.up = 'ArrowUp';\n    this.down = 'ArrowDown';\n  }\n\n  moveLeft() {\n    if (this.status === 'playing') {\n      this.slideTiles(this.left, this.currentState);\n    }\n  }\n  moveRight() {\n    if (this.status === 'playing') {\n      this.slideTiles(this.right, this.currentState);\n    }\n  }\n  moveUp() {\n    if (this.status === 'playing') {\n      this.slideTiles(this.up, this.currentState);\n    }\n  }\n  moveDown() {\n    if (this.status === 'playing') {\n      this.slideTiles(this.down, this.currentState);\n    }\n  }\n\n  getScore() {\n    return this.score;\n  }\n\n  getState() {\n    return this.currentState;\n  }\n\n  getStatus() {\n    return this.status;\n  }\n\n  start() {\n    this.status = 'playing';\n    this.getRandomMatrixValue();\n    this.getRandomMatrixValue();\n  }\n\n  restart() {\n    this.score = 0;\n    this.status = 'idle';\n    this.currentState = JSON.parse(JSON.stringify(this.initialState));\n  }\n\n  getRandomValue() {\n    return Math.random() > 0.9 ? 4 : 2;\n  }\n\n  getRandomCell() {\n    const emptyCells = [];\n\n    for (let i = 0; i < this.currentState.length; i++) {\n      for (let j = 0; j < this.currentState[i].length; j++) {\n        if (this.currentState[i][j] === 0) {\n          emptyCells.push({ row: i, col: j });\n        }\n      }\n    }\n\n    if (emptyCells.length === 0) {\n      return null;\n    }\n\n    const randomIndex = Math.floor(Math.random() * emptyCells.length);\n\n    return emptyCells[randomIndex];\n  }\n\n  getRandomMatrixValue() {\n    const { row, col } = this.getRandomCell();\n    const value = this.getRandomValue();\n\n    if (row >= 0 && col >= 0 && value !== 0) {\n      this.currentState[row][col] = value;\n    }\n  }\n\n  groupCellsByColumn(matrix) {\n    const newGroup = [];\n\n    if (matrix.length > 0) {\n      for (let j = 0; j < matrix.length; j++) {\n        newGroup.push(matrix.map((row) => row[j]));\n      }\n    }\n\n    return newGroup;\n  }\n\n  slideTiles(direction, groupedMatrix) {\n    let hasChanged = false;\n\n    if (direction === this.left || direction === this.right) {\n      for (let i = 0; i < groupedMatrix.length; i++) {\n        const row = this.currentState[i];\n        const newGroup = this.slideTilesInGroup(row, direction === this.right);\n\n        if (row.join(',') !== newGroup.join(',')) {\n          hasChanged = true;\n          this.currentState[i] = newGroup;\n        }\n      }\n    } else if (direction === this.up || direction === this.down) {\n      for (let j = 0; j < groupedMatrix.length; j++) {\n        const column = this.currentState.map((line) => line[j]);\n        const newColumn = this.slideTilesInGroup(\n          column,\n          direction === this.down,\n        );\n\n        for (let i = 0; i < groupedMatrix.length; i++) {\n          if (this.currentState[i][j] !== newColumn[i]) {\n            hasChanged = true;\n            this.currentState[i][j] = newColumn[i];\n          }\n        }\n      }\n    }\n\n    if (hasChanged) {\n      this.getRandomMatrixValue();\n      this.checkGameOver();\n    }\n  }\n\n  slideTilesInGroup(group, isReverse) {\n    const newGroup = group.filter((cell) => cell !== 0);\n\n    if (isReverse) {\n      newGroup.reverse();\n    }\n\n    for (let i = 0; i < newGroup.length; i++) {\n      if (newGroup[i] === newGroup[i + 1]) {\n        newGroup[i] *= 2;\n\n        this.score += newGroup[i];\n        newGroup.splice(i + 1, 1);\n\n        if (newGroup[i] === 2048) {\n          this.status = 'win';\n        }\n      }\n    }\n\n    while (newGroup.length < group.length) {\n      newGroup.push(0);\n    }\n\n    if (isReverse) {\n      newGroup.reverse();\n    }\n\n    return newGroup;\n  }\n\n  checkGameOver() {\n    for (let i = 0; i < this.currentState.length; i++) {\n      for (let j = 0; j < this.currentState[i].length; j++) {\n        if (this.currentState[i][j] === 0) {\n          return;\n        }\n\n        if (\n          j < this.currentState[i].length - 1 &&\n          this.currentState[i][j] === this.currentState[i][j + 1]\n        ) {\n          return;\n        }\n\n        if (\n          i < this.currentState[i].length - 1 &&\n          this.currentState[i][j] === this.currentState[i + 1][j]\n        ) {\n          return;\n        }\n      }\n    }\n\n    this.status = 'lose';\n  }\n}\n\nmodule.exports = Game;\n"],"names":["$a3a4bece0086b835$exports","constructor","value","field","tileElement","document","createElement","classList","add","append","setValue","setCoords","row","col","style","setProperty","textContent","removeFromDom","remove","waitForTransitionEnd","Promise","resolve","addEventListener","once","$a5fd07fa01589658$exports","initialState","currentState","JSON","parse","stringify","status","score","left","right","up","down","moveLeft","slideTiles","moveRight","moveUp","moveDown","getScore","getState","getStatus","start","getRandomMatrixValue","restart","getRandomValue","Math","random","getRandomCell","emptyCells","i","length","j","push","randomIndex","floor","groupCellsByColumn","matrix","newGroup","map","direction","groupedMatrix","hasChanged","slideTilesInGroup","join","column","line","newColumn","checkGameOver","group","isReverse","filter","cell","reverse","splice","gameButton","querySelector","messageWin","messageLose","messageStart","scoreElement","gameField","themeSwitcher","cells","initCells","fieldSize","game","cellsGroupedByColumn","cellsGroupedByReversedColumn","cellsGroupedByRow","groupCellsByRow","cellsGroupedByReversedRow","renderBoard","gameMatrix","existingCell","find","linkedTile","linkTile","tile","reduce","groupedCells","promises","forEach","targetCell","currentTile","cellWithTile","linkedTileForMerge","Object","keys","all","e","target","matches","clearBoard","setupInputOnce","body","themeLight","themeDark","fieldCells","querySelectorAll","buttonUp","buttonDown","buttonLeft","buttonRight","window","handleInput","ev","preventDefault","key","KeyboardEvent"],"version":3,"file":"index.574760c1.js.map"}